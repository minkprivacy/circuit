/**
 * Convert snarkjs verification key to Rust constants
 *
 * This script reads a verification key JSON file from snarkjs and converts it
 * to Rust constants using the hex_literal macro format for the Solana program.
 *
 * Usage:
 *   node scripts/convert_vkey.cjs inbox_registration   # Converts inbox_registration_vkey.json
 *   node scripts/convert_vkey.cjs viewing_key          # Converts viewing_key_vkey.json
 *   node scripts/convert_vkey.cjs stealth_tx           # Converts stealth_tx_vkey.json
 *   node scripts/convert_vkey.cjs --all                # Converts all circuits
 *
 * Output:
 *   Rust files are written to infra/program/programs/skit_privacy/src/verifier/
 */

const fs = require('fs');
const path = require('path');

// Circuit configurations
const CIRCUITS = {
  inbox_registration: {
    name: 'Inbox Registration',
    publicInputs: ['zkPubkey', 'messageHash'],
    outputFile: 'inbox_keys.rs',
    constPrefix: 'INBOX',
    fnName: 'get_inbox_verifying_key',
  },
  viewing_key: {
    name: 'Viewing Key',
    publicInputs: ['zkPubkey', 'viewingKeyHash', 'scope'],
    outputFile: 'viewing_keys.rs',
    constPrefix: 'VIEWING',
    fnName: 'get_viewing_verifying_key',
  },
  stealth_tx: {
    name: 'Stealth Transaction',
    publicInputs: ['root', 'publicAmount', 'extDataHash', 'inputNullifier[0]', 'inputNullifier[1]', 'outputCommitment[0]', 'outputCommitment[1]'],
    outputFile: 'keys.rs',
    constPrefix: '',
    fnName: 'get_verifying_key',
  },
};

const ARTIFACTS_DIR = path.join(__dirname, '..', 'artifacts');
const OUTPUT_DIR = path.join(__dirname, '..', '..', 'program', 'programs', 'mink_privacy', 'src', 'verifier');

/**
 * Convert a decimal string to a big-endian hex string (32 bytes)
 */
function decimalToHex32(decimalStr) {
  let hex = BigInt(decimalStr).toString(16);
  // Pad to 64 characters (32 bytes)
  hex = hex.padStart(64, '0');
  return hex;
}

/**
 * Convert a G1 point from snarkjs format to Solana BN254 format
 * snarkjs G1: [x, y, z] where z=1 for affine
 * Solana: [x (32 bytes BE), y (32 bytes BE)] = 64 bytes
 */
function convertG1Point(point) {
  const x = decimalToHex32(point[0]);
  const y = decimalToHex32(point[1]);
  return x + y;
}

/**
 * Convert a G2 point from snarkjs format to Solana BN254 format
 * snarkjs G2: [[x0, x1], [y0, y1], [z0, z1]] where z=1 for affine
 *
 * For Solana BN254 syscalls, G2 points must be in the format:
 * [x1 (32 bytes), x0 (32 bytes), y1 (32 bytes), y0 (32 bytes)] = 128 bytes
 * Note: x1/x0 order (imaginary first), same for y
 */
function convertG2Point(point) {
  const x0 = decimalToHex32(point[0][0]);
  const x1 = decimalToHex32(point[0][1]);
  const y0 = decimalToHex32(point[1][0]);
  const y1 = decimalToHex32(point[1][1]);

  // Solana expects: x1, x0, y1, y0 (imaginary part first for both)
  return x1 + x0 + y1 + y0;
}

/**
 * Format hex string into Rust hex_literal macro format
 * Splits into lines of 64 characters (32 bytes) for readability
 */
function formatHexLiteral(hex, indent = '    ') {
  const lines = [];
  for (let i = 0; i < hex.length; i += 64) {
    lines.push(`${indent}"${hex.slice(i, i + 64)}"`);
  }
  return lines.join('\n');
}

/**
 * Generate Rust file content from verification key
 */
function generateRustFile(vkey, config) {
  const nPublic = vkey.IC.length - 1;
  const prefix = config.constPrefix ? `_${config.constPrefix}` : '';
  const prefixUpper = config.constPrefix || '';

  // Convert all points
  const alphaG1 = convertG1Point(vkey.vk_alpha_1);
  const betaG2 = convertG2Point(vkey.vk_beta_2);
  const gammaG2 = convertG2Point(vkey.vk_gamma_2);
  const deltaG2 = convertG2Point(vkey.vk_delta_2);
  const icPoints = vkey.IC.map(convertG1Point);

  // Generate IC array items
  const icItems = icPoints.map((hex, i) => {
    return `    hex_literal::hex!(\n${formatHexLiteral(hex, '        ')}\n    ),`;
  }).join('\n');

  const publicInputsComment = config.publicInputs.map((p, i) => `${i}: ${p}`).join(', ');

  const content = `//! Verification Key for ${config.name} Circuit
//!
//! Auto-generated by convert_vkey.cjs - DO NOT EDIT
//!
//! Public inputs (${nPublic}): ${publicInputsComment}

use super::groth16::Groth16VerifyingKey;

/// Number of public inputs in the circuit
pub const N_PUBLIC${prefix}: usize = ${nPublic};

/// VK_ALPHA_G1${prefix} - G1 point (64 bytes)
pub const VK_ALPHA_G1${prefix}: [u8; 64] = hex_literal::hex!(
${formatHexLiteral(alphaG1)}
);

/// VK_BETA_G2${prefix} - G2 point (128 bytes)
pub const VK_BETA_G2${prefix}: [u8; 128] = hex_literal::hex!(
${formatHexLiteral(betaG2)}
);

/// VK_GAMMA_G2${prefix} - G2 point (128 bytes)
pub const VK_GAMMA_G2${prefix}: [u8; 128] = hex_literal::hex!(
${formatHexLiteral(gammaG2)}
);

/// VK_DELTA_G2${prefix} - G2 point (128 bytes)
pub const VK_DELTA_G2${prefix}: [u8; 128] = hex_literal::hex!(
${formatHexLiteral(deltaG2)}
);

/// VK_IC${prefix} - Input Coefficients for public input verification
pub const VK_IC${prefix}: [[u8; 64]; ${icPoints.length}] = [
${icItems}
];

/// Get the verification key for ${config.name.toLowerCase()} circuit
pub fn ${config.fnName}<'a>() -> Groth16VerifyingKey<'a> {
    Groth16VerifyingKey {
        nr_pubinputs: N_PUBLIC${prefix},
        vk_alpha_g1: VK_ALPHA_G1${prefix},
        vk_beta_g2: VK_BETA_G2${prefix},
        vk_gamma_g2: VK_GAMMA_G2${prefix},
        vk_delta_g2: VK_DELTA_G2${prefix},
        vk_ic: &VK_IC${prefix},
    }
}
`;

  return content;
}

/**
 * Convert a single circuit's verification key
 */
function convertCircuit(circuitName) {
  const config = CIRCUITS[circuitName];
  if (!config) {
    console.error(`Unknown circuit: ${circuitName}`);
    console.error(`Available circuits: ${Object.keys(CIRCUITS).join(', ')}`);
    process.exit(1);
  }

  const vkeyPath = path.join(ARTIFACTS_DIR, `${circuitName}_vkey.json`);

  if (!fs.existsSync(vkeyPath)) {
    throw new Error(`Verification key not found: ${vkeyPath}\nRun 'pnpm build:${circuitName.replace('_', ':')}' first to generate it.`);
  }

  console.log(`Converting ${circuitName}...`);

  const vkey = JSON.parse(fs.readFileSync(vkeyPath, 'utf8'));
  const rustContent = generateRustFile(vkey, config);

  const outputPath = path.join(OUTPUT_DIR, config.outputFile);

  // Ensure output directory exists
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  fs.writeFileSync(outputPath, rustContent);
  console.log(`  -> ${outputPath}`);
}

/**
 * Main entry point
 */
function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log('Usage: node scripts/convert_vkey.cjs <circuit_name>');
    console.log('       node scripts/convert_vkey.cjs --all');
    console.log('');
    console.log('Available circuits:');
    for (const [name, config] of Object.entries(CIRCUITS)) {
      console.log(`  ${name} - ${config.name} (${config.publicInputs.length} public inputs)`);
    }
    process.exit(0);
  }

  if (args[0] === '--all') {
    console.log('Converting all verification keys...\n');
    let converted = 0;
    let skipped = 0;
    for (const circuitName of Object.keys(CIRCUITS)) {
      try {
        convertCircuit(circuitName);
        converted++;
      } catch (err) {
        console.warn(`  Skipping ${circuitName}: ${err.message.split('\n')[0]}`);
        skipped++;
      }
    }
    console.log(`\nDone! Converted: ${converted}, Skipped: ${skipped}`);
  } else {
    try {
      convertCircuit(args[0]);
      console.log('\nDone!');
    } catch (err) {
      console.error(err.message);
      process.exit(1);
    }
  }
}

main();
